#!/bin/bash

# UICTL - Unified GNOME Configuration Control
# Jednotn√© rozhran√≠ pro backup a restore GNOME nastaven√≠

# Barevn√© v√Ωstupy
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Glob√°ln√≠ promƒõnn√©
FORCE=false
DRY_RUN=false
QUIET=false
VERBOSE=false

# Funkce pro barevn√© v√Ωpisy
print_info() { [ "$QUIET" != "true" ] && echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
print_success() { [ "$QUIET" != "true" ] && echo -e "${GREEN}‚úÖ $1${NC}"; }
print_warning() { [ "$QUIET" != "true" ] && echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
print_error() { echo -e "${RED}‚ùå $1${NC}" >&2; }
print_verbose() { [ "$VERBOSE" = "true" ] && echo -e "${BLUE}üîç $1${NC}"; }

# Z√≠sk√°n√≠ aktu√°ln√≠ho adres√°≈ôe scriptu
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BACKUP_DIR="$SCRIPT_DIR/backups"

# Hlavn√≠ help funkce
show_main_help() {
    cat << 'EOF'
üñ•Ô∏è  UICTL - Unified GNOME Configuration Control

Pou≈æit√≠: uictl <p≈ô√≠kaz> [mo≈ænosti] [argumenty]

P≈ô√≠kazy:
  backup              Vytvo≈ô√≠ z√°lohu GNOME nastaven√≠
  restore <backup>    Obnov√≠ z√°lohu GNOME nastaven√≠  
  list                Zobraz√≠ dostupn√© z√°lohy
  status              Zobraz√≠ info o nejnovƒõj≈°√≠ z√°loze
  diff [backup]       Porovn√° aktu√°ln√≠ nastaven√≠ se z√°lohou
  clean [poƒçet]       Vyƒçist√≠ star√© z√°lohy (ponech√° posledn√≠ch N)
  help [p≈ô√≠kaz]       Zobraz√≠ n√°povƒõdu

Glob√°ln√≠ mo≈ænosti:
  -f, --force         Neptat se na potvrzen√≠
  -d, --dry-run       Pouze zobraz√≠ co by se dƒõlalo (restore/clean)
  -q, --quiet         Tich√Ω re≈æim
  -v, --verbose       Podrobn√Ω v√Ωstup
  -h, --help          Zobraz√≠ n√°povƒõdu

P≈ô√≠klady:
  uictl backup                    Vytvo≈ô√≠ z√°lohu
  uictl list                      Zobraz√≠ z√°lohy
  uictl restore latest            Obnov√≠ nejnovƒõj≈°√≠ z√°lohu
  uictl restore backup_20240630   Obnov√≠ specifickou z√°lohu
  uictl status                    Uk√°≈æe info o nejnovƒõj≈°√≠ z√°loze
  uictl diff                      Porovn√° s nejnovƒõj≈°√≠ z√°lohou
  uictl diff backup_20240630      Porovn√° s konkr√©tn√≠ z√°lohou
  uictl clean 5                   Ponech√° jen posledn√≠ch 5 z√°loh
  uictl help restore              N√°povƒõda pro p≈ô√≠kaz restore

Pro podrobnou n√°povƒõdu k p≈ô√≠kazu: uictl help <p≈ô√≠kaz>
EOF
}

# Help pro jednotliv√© p≈ô√≠kazy
show_command_help() {
    case "$1" in
        backup)
            cat << 'EOF'
üì¶ uictl backup - Vytvo≈ô√≠ z√°lohu GNOME nastaven√≠

Pou≈æit√≠: uictl backup [mo≈ænosti]

Vytvo≈ô√≠ kompletn√≠ z√°lohu v≈°ech GNOME nastaven√≠ vƒçetnƒõ:
- Dconf nastaven√≠ (v≈°echna GNOME nastaven√≠)
- Konfiguraƒçn√≠ soubory (~/.config)
- GNOME Shell extensions
- GTK t√©mata a nastaven√≠
- Monitor konfigurace
- Autostart aplikace

Mo≈ænosti:
  -q, --quiet    Tich√Ω re≈æim (pouze chyby)
  -v, --verbose  Podrobn√Ω v√Ωstup

P≈ô√≠klady:
  uictl backup          Standardn√≠ z√°loha
  uictl backup -v       Podrobn√° z√°loha
EOF
            ;;
        restore)
            cat << 'EOF'
üîÑ uictl restore - Obnov√≠ z√°lohu GNOME nastaven√≠

Pou≈æit√≠: uictl restore <backup> [mo≈ænosti]

Argumenty:
  backup              N√°zev z√°lohy (backup_YYYYMMDD_HHMMSS)
                     nebo 'latest' pro nejnovƒõj≈°√≠

Mo≈ænosti:
  -f, --force        Neptat se na potvrzen√≠
  -d, --dry-run      Pouze uk√°≈æe co by se dƒõlalo
  -q, --quiet        Tich√Ω re≈æim
  -v, --verbose      Podrobn√Ω v√Ωstup

P≈ô√≠klady:
  uictl restore latest              Obnov√≠ nejnovƒõj≈°√≠ z√°lohu
  uictl restore backup_20240630     Obnov√≠ specifickou z√°lohu  
  uictl restore -d latest           Dry-run re≈æim
  uictl restore -f latest           Bez potvrzen√≠

‚ö†Ô∏è  POZOR: Restore p≈ôep√≠≈°e va≈°e souƒçasn√© GNOME nastaven√≠!
P≈ôed obnoven√≠m se automaticky vytvo≈ô√≠ z√°loha souƒçasn√©ho stavu.
EOF
            ;;
        list)
            cat << 'EOF'
üìÇ uictl list - Zobraz√≠ dostupn√© z√°lohy

Pou≈æit√≠: uictl list [mo≈ænosti]

Zobraz√≠ seznam v≈°ech dostupn√Ωch z√°loh vƒçetnƒõ:
- N√°zev z√°lohy
- Datum a ƒças vytvo≈ôen√≠
- Velikost z√°lohy
- Symlink na nejnovƒõj≈°√≠ z√°lohu

Mo≈ænosti:
  -q, --quiet    Pouze n√°zvy z√°loh
  -v, --verbose  Podrobn√© informace

P≈ô√≠klad:
  uictl list       Zobraz√≠ v≈°echny z√°lohy
EOF
            ;;
        status)
            cat << 'EOF'
üìä uictl status - Zobraz√≠ informace o nejnovƒõj≈°√≠ z√°loze

Pou≈æit√≠: uictl status [mo≈ænosti]

Zobraz√≠ podrobn√© informace o nejnovƒõj≈°√≠ z√°loze:
- Datum a ƒças vytvo≈ôen√≠
- Velikost z√°lohy
- Syst√©mov√© informace z doby vytvo≈ôen√≠
- Obsah z√°lohy

P≈ô√≠klad:
  uictl status     Zobraz√≠ info o nejnovƒõj≈°√≠ z√°loze
EOF
            ;;
        clean)
            cat << 'EOF'
üßπ uictl clean - Vyƒçist√≠ star√© z√°lohy

Pou≈æit√≠: uictl clean [poƒçet] [mo≈ænosti]

Argumenty:
  poƒçet               Poƒçet nejnovƒõj≈°√≠ch z√°loh k ponech√°n√≠ (v√Ωchoz√≠: 10)

Mo≈ænosti:
  -f, --force        Neptat se na potvrzen√≠
  -d, --dry-run      Pouze uk√°≈æe co by se smazalo
  -q, --quiet        Tich√Ω re≈æim
  -v, --verbose      Podrobn√Ω v√Ωstup

P≈ô√≠klady:
  uictl clean              Ponech√° posledn√≠ch 10 z√°loh
  uictl clean 5            Ponech√° posledn√≠ch 5 z√°loh
  uictl clean -d           Uk√°≈æe co by se smazalo
EOF
            ;;
        diff)
            cat << 'EOF'
üîç uictl diff - Porovn√°n√≠ aktu√°ln√≠ho nastaven√≠ se z√°lohou

Pou≈æit√≠: uictl diff [backup] [mo≈ænosti]

Argumenty:
  backup              N√°zev z√°lohy k porovn√°n√≠ (backup_YYYYMMDD_HHMMSS)
                     nebo 'latest' pro nejnovƒõj≈°√≠ (v√Ωchoz√≠)

Mo≈ænosti:
  -q, --quiet        Tich√Ω re≈æim (pouze z√°kladn√≠ rozd√≠ly)  
  -v, --verbose      Podrobn√Ω v√Ωstup s detaily
  -d, --dry-run      Alias pro tich√Ω re≈æim (kompatibilita)

Porovn√°v√°:
  - Dconf nastaven√≠ (GNOME konfigurace)  
  - GNOME konfiguraƒçn√≠ soubory (GTK, autostart, monitor setup atd.)
  - Povolen√© GNOME Shell extensions
  - Lok√°ln√≠ GNOME data

Pozn√°mka: Porovn√°v√° jen soubory kter√© uictl z√°lohuje (GNOME-souvisej√≠c√≠).
         Ignoruje doƒçasn√© a backup soubory (*.backup-*, *~, *.tmp).

P≈ô√≠klady:
  uictl diff                       Porovn√° s nejnovƒõj≈°√≠ z√°lohou
  uictl diff latest                Porovn√° s nejnovƒõj≈°√≠ z√°lohou
  uictl diff backup_20240630       Porovn√° s konkr√©tn√≠ z√°lohou
  uictl diff -v backup_20240630    Podrobn√© porovn√°n√≠
EOF
            ;;
        *)
            print_error "Nezn√°m√Ω p≈ô√≠kaz: $1"
            echo "Dostupn√© p≈ô√≠kazy: backup, restore, list, status, diff, clean"
            ;;
    esac
}

# Funkce pro v√Ωpis dostupn√Ωch z√°loh
list_backups() {
    print_verbose "Kontroluji adres√°≈ô z√°loh: $BACKUP_DIR"
    
    if [ ! -d "$BACKUP_DIR" ]; then
        print_warning "Adres√°≈ô se z√°lohami neexistuje: $BACKUP_DIR"
        return 1
    fi
    
    local backup_files=($(ls "$BACKUP_DIR"/backup_* 2>/dev/null || true))
    if [ ${#backup_files[@]} -eq 0 ]; then
        print_warning "≈Ω√°dn√© z√°lohy nenalezeny"
        return 1
    fi
    
    if [ "$QUIET" != "true" ]; then
        print_info "üìÇ Dostupn√© z√°lohy v $BACKUP_DIR:"
        echo
    fi
    
    for backup in "$BACKUP_DIR"/backup_*; do
        if [ -d "$backup" ]; then
            backup_name=$(basename "$backup")
            backup_date=$(echo "$backup_name" | sed 's/backup_//' | sed 's/_/ /')
            backup_size=$(du -sh "$backup" 2>/dev/null | cut -f1 || echo "N/A")
            
            if [ "$QUIET" = "true" ]; then
                echo "$backup_name"
            else
                printf "  %-25s %s (%s)\n" "$backup_name" "$backup_date" "$backup_size"
            fi
        fi
    done
    
    if [ "$QUIET" != "true" ]; then
        echo
        if [ -L "$BACKUP_DIR/latest" ]; then
            latest_target=$(readlink "$BACKUP_DIR/latest")
            print_info "üîó Nejnovƒõj≈°√≠ z√°loha: $latest_target"
        fi
    fi
}

# Funkce pro zobrazen√≠ stavu
show_status() {
    if [ ! -L "$BACKUP_DIR/latest" ]; then
        print_warning "≈Ω√°dn√° z√°loha nenalezena"
        return 1
    fi
    
    latest_backup="$BACKUP_DIR/$(readlink "$BACKUP_DIR/latest")"
    
    if [ ! -d "$latest_backup" ]; then
        print_error "Nejnovƒõj≈°√≠ z√°loha neexistuje: $latest_backup"
        return 1
    fi
    
    print_info "üìä Status nejnovƒõj≈°√≠ z√°lohy:"
    echo
    
    backup_name=$(basename "$latest_backup")
    backup_date=$(echo "$backup_name" | sed 's/backup_//' | sed 's/_/ /')
    backup_size=$(du -sh "$latest_backup" 2>/dev/null | cut -f1 || echo "N/A")
    
    printf "  N√°zev:      %s\n" "$backup_name"
    printf "  Datum:      %s\n" "$backup_date"
    printf "  Velikost:   %s\n" "$backup_size"
    echo
    
    if [ -f "$latest_backup/backup-info.txt" ]; then
        print_info "üìã Informace o z√°loze:"
        cat "$latest_backup/backup-info.txt" | sed 's/^/  /'
        echo
    fi
    
    if [ "$VERBOSE" = "true" ]; then
        print_info "üìÅ Obsah z√°lohy:"
        find "$latest_backup" -type f | sed 's|^'"$latest_backup"'/|  |' | sort
    fi
}

# Funkce pro ƒçi≈°tƒõn√≠ star√Ωch z√°loh
clean_old_backups() {
    local keep_count=${1:-10}
    
    print_verbose "Hled√°m z√°lohy k vyƒçi≈°tƒõn√≠, ponech√°m posledn√≠ch $keep_count"
    
    if [ ! -d "$BACKUP_DIR" ]; then
        print_warning "Adres√°≈ô se z√°lohami neexistuje"
        return 0
    fi
    
    # Naj√≠t v≈°echny z√°lohy se≈ôazen√© podle data (nejnovƒõj≈°√≠ prvn√≠)
    local backups=()
    while IFS= read -r -d '' backup; do
        if [ -d "$backup" ]; then
            backups+=("$backup")
        fi
    done < <(find "$BACKUP_DIR" -maxdepth 1 -name "backup_*" -type d -print0 | sort -z -r)
    local total_backups=${#backups[@]}
    
    if [ $total_backups -le $keep_count ]; then
        print_info "Nalezeno $total_backups z√°loh, ≈æ√°dn√© ƒçi≈°tƒõn√≠ nen√≠ pot≈ôeba (limit: $keep_count)"
        return 0
    fi
    
    local to_delete=(${backups[@]:$keep_count})
    local delete_count=${#to_delete[@]}
    
    print_info "Nalezeno $total_backups z√°loh, bude smaz√°no $delete_count star√Ωch z√°loh"
    
    if [ "$DRY_RUN" = "true" ]; then
        print_warning "üß™ DRY-RUN re≈æim - z√°lohy by byly smaz√°ny:"
        for backup in "${to_delete[@]}"; do
            backup_name=$(basename "$backup")
            backup_size=$(du -sh "$backup" 2>/dev/null | cut -f1 || echo "N/A")
            echo "  $backup_name ($backup_size)"
        done
        return 0
    fi
    
    if [ "$FORCE" != "true" ]; then
        echo
        print_warning "üóëÔ∏è  Budou smaz√°ny n√°sleduj√≠c√≠ z√°lohy:"
        for backup in "${to_delete[@]}"; do
            backup_name=$(basename "$backup")
            backup_size=$(du -sh "$backup" 2>/dev/null | cut -f1 || echo "N/A")
            echo "  $backup_name ($backup_size)"
        done
        echo
        read -p "Pokraƒçovat se smaz√°n√≠m? (ano/ne): " -r
        if [[ ! $REPLY =~ ^[Aa]no$ ]]; then
            print_info "Operace zru≈°ena"
            return 0
        fi
    fi
    
    # Smaz√°n√≠ star√Ωch z√°loh
    for backup in "${to_delete[@]}"; do
        if [ -d "$backup" ]; then
            backup_name=$(basename "$backup")
            print_verbose "Maz√°m z√°lohu: $backup_name"
            rm -rf "$backup"
            print_success "Smaz√°no: $backup_name"
        fi
    done
    
    print_success "Vyƒçi≈°tƒõn√≠ dokonƒçeno - smaz√°no $delete_count z√°loh"
}

# Funkce pro vytvo≈ôen√≠ z√°lohy (ze star√©ho backup.sh)
create_backup() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local current_backup="$BACKUP_DIR/backup_$timestamp"
    
    print_info "üîÑ Spou≈°t√≠m z√°lohu GNOME nastaven√≠..."
    print_verbose "üìÇ C√≠lov√Ω adres√°≈ô: $current_backup"
    
    mkdir -p "$current_backup"
    mkdir -p "$current_backup/config"
    mkdir -p "$current_backup/local"
    mkdir -p "$current_backup/dconf"
    
    print_info "üìä Exportuji dconf nastaven√≠..."
    dconf dump / > "$current_backup/dconf/all-settings.ini"
    dconf dump /org/gnome/shell/extensions/ > "$current_backup/dconf/extensions-settings.ini"
    dconf dump /org/gnome/desktop/ > "$current_backup/dconf/desktop-settings.ini"
    dconf dump /org/gnome/settings-daemon/ > "$current_backup/dconf/settings-daemon.ini"
    dconf dump /org/gnome/mutter/ > "$current_backup/dconf/mutter-settings.ini"
    print_success "Dconf nastaven√≠ exportov√°na"
    
    print_info "üìÅ Kop√≠ruji konfiguraƒçn√≠ soubory..."
    [ -d ~/.config/dconf ] && cp -r ~/.config/dconf "$current_backup/config/" && print_verbose "dconf slo≈æka zkop√≠rov√°na"
    [ -d ~/.config/gtk-2.0 ] && cp -r ~/.config/gtk-2.0 "$current_backup/config/" && print_verbose "GTK 2.0 nastaven√≠ zkop√≠rov√°na"
    [ -d ~/.config/gtk-3.0 ] && cp -r ~/.config/gtk-3.0 "$current_backup/config/" && print_verbose "GTK 3.0 nastaven√≠ zkop√≠rov√°na"
    [ -d ~/.config/gtk-4.0 ] && cp -r ~/.config/gtk-4.0 "$current_backup/config/" && print_verbose "GTK 4.0 nastaven√≠ zkop√≠rov√°na"
    [ -d ~/.config/autostart ] && cp -r ~/.config/autostart "$current_backup/config/" && print_verbose "Autostart aplikace zkop√≠rov√°ny"
    [ -d ~/.config/tiling-assistant ] && cp -r ~/.config/tiling-assistant "$current_backup/config/" && print_verbose "Tiling Assistant nastaven√≠ zkop√≠r√°na"
    [ -d ~/.config/gnome-session ] && cp -r ~/.config/gnome-session "$current_backup/config/" && print_verbose "GNOME Session nastaven√≠ zkop√≠r√°na"
    
    [ -f ~/.config/monitors.xml ] && cp ~/.config/monitors.xml "$current_backup/config/" && print_verbose "Monitor nastaven√≠ zkop√≠rov√°no"
    [ -f ~/.config/mimeapps.list ] && cp ~/.config/mimeapps.list "$current_backup/config/" && print_verbose "MIME aplikace zkop√≠rov√°ny"
    [ -f ~/.config/user-dirs.dirs ] && cp ~/.config/user-dirs.dirs "$current_backup/config/" && print_verbose "U≈æivatelsk√© adres√°≈ôe zkop√≠rov√°ny"
    print_success "Konfiguraƒçn√≠ soubory zkop√≠rov√°ny"
    
    print_info "üîå Z√°lohuju GNOME Shell extensions..."
    if [ -d ~/.local/share/gnome-shell/extensions ]; then
        cp -r ~/.local/share/gnome-shell/extensions "$current_backup/local/"
        print_success "U≈æivatelsk√© extensions zkop√≠rov√°ny"
    else
        print_warning "≈Ω√°dn√© u≈æivatelsk√© extensions nenalezeny"
    fi
    
    [ -d ~/.local/share/gnome-shell ] && cp -r ~/.local/share/gnome-shell "$current_backup/local/" && print_verbose "GNOME Shell data zkop√≠rov√°na"
    [ -d ~/.local/share/applications ] && cp -r ~/.local/share/applications "$current_backup/local/" && print_verbose "U≈æivatelsk√© aplikace zkop√≠rov√°ny"
    
    print_info "üìù Ukl√°d√°m metadata..."
    gsettings get org.gnome.shell enabled-extensions > "$current_backup/enabled-extensions.txt"
    ls /usr/share/gnome-shell/extensions/ > "$current_backup/system-extensions.txt" 2>/dev/null || echo "≈Ω√°dn√© syst√©mov√© extensions" > "$current_backup/system-extensions.txt"
    
    echo "GNOME Backup - $(date)" > "$current_backup/backup-info.txt"
    echo "Hostname: $(hostname)" >> "$current_backup/backup-info.txt"
    echo "User: $(whoami)" >> "$current_backup/backup-info.txt"
    echo "GNOME Version: $(gnome-shell --version 2>/dev/null || echo 'Unknown')" >> "$current_backup/backup-info.txt"
    echo "OS: $(lsb_release -d 2>/dev/null | cut -d: -f2 | xargs || echo 'Unknown')" >> "$current_backup/backup-info.txt"
    echo "Kernel: $(uname -r)" >> "$current_backup/backup-info.txt"
    print_success "Metadata ulo≈æena"
    
    # Create/update symlink to latest backup
    cd "$BACKUP_DIR" && rm -f latest && ln -sf "backup_$timestamp" latest
    print_verbose "Latest symlink aktualizov√°n"
    
    print_info "üßπ ƒåist√≠m doƒçasn√© soubory ze z√°lohy..."
    find "$current_backup" -name "*.backup-[0-9]*" -type d -exec rm -rf {} + 2>/dev/null || true
    find "$current_backup" -name "*.backup-[0-9]*" -type f -exec rm -f {} + 2>/dev/null || true
    print_verbose "Doƒçasn√© soubory vyƒçi≈°tƒõny"
    
    local backup_size=$(du -sh "$current_backup" | cut -f1)
    
    print_success "üéâ Z√°loha √∫spƒõ≈°nƒõ dokonƒçena!"
    print_info "üìÇ Um√≠stƒõn√≠ z√°lohy: $current_backup"
    print_info "üîó Symlink na nejnovƒõj≈°√≠: $BACKUP_DIR/latest"
    print_info "üíæ Velikost z√°lohy: $backup_size"
    
    if [ "$VERBOSE" = "true" ]; then
        echo
        print_info "üìã Obsah z√°lohy:"
        find "$current_backup" -type f | sed 's|^'"$current_backup"'/|  |' | sort
    fi
}

# Funkce pro vytvo≈ôen√≠ z√°lohy p≈ôed obnoven√≠m
create_pre_restore_backup() {
    print_info "üíæ Vytv√°≈ô√≠m z√°lohu p≈ôed obnoven√≠m..."
    local pre_restore_backup="$BACKUP_DIR/pre-restore-backup_$(date +%Y%m%d_%H%M%S)"
    
    mkdir -p "$pre_restore_backup/config"
    mkdir -p "$pre_restore_backup/dconf"
    
    dconf dump / > "$pre_restore_backup/dconf/current-settings.ini" 2>/dev/null || true
    [ -d ~/.config/dconf ] && cp -r ~/.config/dconf "$pre_restore_backup/config/" 2>/dev/null || true
    [ -d ~/.local/share/gnome-shell/extensions ] && cp -r ~/.local/share/gnome-shell/extensions "$pre_restore_backup/" 2>/dev/null || true
    
    print_success "Z√°loha p≈ôed obnoven√≠m vytvo≈ôena: $(basename "$pre_restore_backup")"
}

# Helper funkce pro porovn√°n√≠ dconf nastaven√≠
compare_dconf() {
    local backup_path="$1"
    local dconf_backup="$backup_path/dconf/all-settings.ini"
    local extensions_backup="$backup_path/dconf/extensions-settings.ini"
    
    print_info "üìä Porovn√°v√°m dconf nastaven√≠..."
    
    # Compare main dconf settings
    if [ -f "$dconf_backup" ]; then
        # Create temporary file with current settings
        local temp_current="/tmp/uictl-current-dconf-$(date +%s).ini"
        dconf dump / > "$temp_current" 2>/dev/null
        
        if [ "$VERBOSE" = "true" ]; then
            # Detailed diff with context
            if ! diff -u "$dconf_backup" "$temp_current" > /dev/null 2>&1; then
                print_warning "üîÑ Rozd√≠ly v hlavn√≠m dconf nastaven√≠:"
                # Use delta if available, otherwise fall back to colored diff
                if command -v delta >/dev/null 2>&1; then
                    diff -u "$dconf_backup" "$temp_current" | delta --paging=never --line-numbers
                else
                    diff -u --color=always "$dconf_backup" "$temp_current" | sed 's/^/  /'
                fi
            else
                print_success "Hlavn√≠ dconf nastaven√≠ jsou identick√°"
            fi
        else
            # Simple comparison
            if ! diff -q "$dconf_backup" "$temp_current" > /dev/null 2>&1; then
                print_warning "üîÑ Hlavn√≠ dconf nastaven√≠ se li≈°√≠ od z√°lohy"
            else
                print_success "Hlavn√≠ dconf nastaven√≠ jsou identick√°"
            fi
        fi
        
        rm -f "$temp_current"
    else
        print_warning "Hlavn√≠ dconf z√°loha nenalezena v: $dconf_backup"
    fi
    
    # Compare extensions settings separately
    if [ -f "$extensions_backup" ]; then
        print_info "üîå Porovn√°v√°m nastaven√≠ extensions..."
        
        local temp_extensions="/tmp/uictl-current-extensions-$(date +%s).ini"
        dconf dump /org/gnome/shell/extensions/ > "$temp_extensions" 2>/dev/null
        
        if [ "$VERBOSE" = "true" ]; then
            if ! diff -u "$extensions_backup" "$temp_extensions" > /dev/null 2>&1; then
                print_warning "üîÑ Rozd√≠ly v nastaven√≠ extensions:"
                if command -v delta >/dev/null 2>&1; then
                    diff -u "$extensions_backup" "$temp_extensions" | delta --paging=never --line-numbers
                else
                    diff -u --color=always "$extensions_backup" "$temp_extensions" | sed 's/^/  /'
                fi
            else
                print_success "Nastaven√≠ extensions jsou identick√°"
            fi
        else
            if ! diff -q "$extensions_backup" "$temp_extensions" > /dev/null 2>&1; then
                print_warning "üîÑ Nastaven√≠ extensions se li≈°√≠ od z√°lohy"
            else
                print_success "Nastaven√≠ extensions jsou identick√°"
            fi
        fi
        
        rm -f "$temp_extensions"
    else
        print_warning "Extensions z√°loha nenalezena v: $extensions_backup"
    fi
}

# Helper funkce pro porovn√°n√≠ konfiguraƒçn√≠ch soubor≈Ø
compare_config_files() {
    local backup_path="$1"
    local config_backup="$backup_path/config"
    
    if [ ! -d "$config_backup" ]; then
        print_warning "Config z√°loha nenalezena v: $config_backup"
        return 1
    fi
    
    print_info "üìÅ Porovn√°v√°m konfiguraƒçn√≠ soubory (jen GNOME-souvisej√≠c√≠)..."
    
    local differences=0
    
    for config_item in "$config_backup"/*; do
        if [ -e "$config_item" ]; then
            local item_name=$(basename "$config_item")
            local current_path="$HOME/.config/$item_name"
            
            # Skip backup files and temporary files (not relevant for config comparison)
            if [[ "$item_name" =~ \.backup-[0-9]+$ ]] || [[ "$item_name" =~ ~$ ]] || [[ "$item_name" =~ \.tmp$ ]]; then
                print_verbose "  $item_name: p≈ôeskakuji (doƒçasn√Ω/backup soubor)"
                continue
            fi
            
            if [ ! -e "$current_path" ]; then
                print_warning "  $item_name: chyb√≠ v aktu√°ln√≠ konfiguraci"
                differences=$((differences + 1))
            elif [ -d "$config_item" ] && [ -d "$current_path" ]; then
                # Compare directories using rsync dry-run
                if ! rsync -rczn --delete "$config_item/" "$current_path/" >/dev/null 2>&1; then
                    print_warning "  $item_name: adres√°≈ô se li≈°√≠"
                    differences=$((differences + 1))
                    if [ "$VERBOSE" = "true" ]; then
                        rsync -rczn --delete --itemize-changes "$config_item/" "$current_path/" 2>/dev/null | head -10 | sed 's/^/    /'
                    fi
                elif [ "$VERBOSE" = "true" ]; then
                    print_success "  $item_name: adres√°≈ô identick√Ω"
                fi
            elif [ -f "$config_item" ] && [ -f "$current_path" ]; then
                # Compare files
                if ! diff -q "$config_item" "$current_path" >/dev/null 2>&1; then
                    print_warning "  $item_name: soubor se li≈°√≠"
                    differences=$((differences + 1))
                    if [ "$VERBOSE" = "true" ]; then
                        # Use delta if available, otherwise fall back to colored diff
                        if command -v delta >/dev/null 2>&1; then
                            diff -u "$config_item" "$current_path" | head -20 | delta --paging=never --line-numbers
                        else
                            diff -u --color=always "$config_item" "$current_path" | head -20 | sed 's/^/    /'
                        fi
                    fi
                elif [ "$VERBOSE" = "true" ]; then
                    print_success "  $item_name: soubor identick√Ω"
                fi
            fi
        fi
    done
    
    # Check only GNOME-related config items that uictl actually backs up
    # This prevents diff from showing irrelevant non-GNOME application changes
    local gnome_config_items=(
        "dconf"
        "gtk-2.0" 
        "gtk-3.0"
        "gtk-4.0"
        "autostart"
        "tiling-assistant"
        "gnome-session"
        "monitors.xml"
        "mimeapps.list" 
        "user-dirs.dirs"
    )
    
    for item_name in "${gnome_config_items[@]}"; do
        local current_item="$HOME/.config/$item_name"
        local backup_item="$config_backup/$item_name"
        
        # Skip backup files and temporary files (not relevant for config comparison)
        if [[ "$item_name" =~ \.backup-[0-9]+$ ]] || [[ "$item_name" =~ ~$ ]] || [[ "$item_name" =~ \.tmp$ ]]; then
            print_verbose "  $item_name: p≈ôeskakuji (doƒçasn√Ω/backup soubor)"
            continue
        fi
        
        if [ -e "$current_item" ] && [ ! -e "$backup_item" ]; then
            print_info "  $item_name: nov√Ω v aktu√°ln√≠ konfiguraci (nen√≠ v z√°loze)"
            differences=$((differences + 1))
        elif [ ! -e "$current_item" ] && [ -e "$backup_item" ]; then
            print_warning "  $item_name: chyb√≠ v aktu√°ln√≠ konfiguraci (byl v z√°loze)"
            differences=$((differences + 1))
        fi
    done
    
    if [ $differences -eq 0 ]; then
        print_success "Konfiguraƒçn√≠ soubory jsou identick√©"
    else
        print_warning "Nalezeno $differences rozd√≠l≈Ø v konfiguraƒçn√≠ch souborech"
    fi
}

# Helper funkce pro porovn√°n√≠ extensions
compare_extensions() {
    local backup_path="$1"
    
    print_info "üîå Porovn√°v√°m GNOME Shell extensions..."
    
    # Compare enabled extensions
    if [ -f "$backup_path/enabled-extensions.txt" ]; then
        local backup_extensions=$(cat "$backup_path/enabled-extensions.txt")
        local current_extensions=$(gsettings get org.gnome.shell enabled-extensions 2>/dev/null || echo "[]")
        
        if [ "$backup_extensions" != "$current_extensions" ]; then
            print_warning "üîÑ Seznam povolen√Ωch extensions se li≈°√≠"
            if [ "$VERBOSE" = "true" ]; then
                echo "  Z√°loha:    $backup_extensions" | sed 's/^/  /'
                echo "  Aktu√°ln√≠:  $current_extensions" | sed 's/^/  /'
            fi
        else
            print_success "Seznam povolen√Ωch extensions je identick√Ω"
        fi
    fi
    
    # Compare user extensions directory
    local extensions_backup="$backup_path/local/extensions"
    local current_extensions_dir="$HOME/.local/share/gnome-shell/extensions"
    
    if [ -d "$extensions_backup" ]; then
        if [ ! -d "$current_extensions_dir" ]; then
            print_warning "  Adres√°≈ô extensions chyb√≠ v aktu√°ln√≠ instalaci"
        elif ! rsync -rczn --delete "$extensions_backup/" "$current_extensions_dir/" >/dev/null 2>&1; then
            print_warning "üîÑ Adres√°≈ô extensions se li≈°√≠"
            if [ "$VERBOSE" = "true" ]; then
                rsync -rczn --delete --itemize-changes "$extensions_backup/" "$current_extensions_dir/" 2>/dev/null | head -10 | sed 's/^/    /'
            fi
        else
            print_success "Adres√°≈ô extensions je identick√Ω"
        fi
    fi
}

# Funkce pro porovn√°n√≠ aktu√°ln√≠ho nastaven√≠ se z√°lohou
diff_settings() {
    local backup_name="${1:-latest}"
    local backup_path
    
    # Resolve backup path
    if [[ "$backup_name" == "latest" ]]; then
        if [ -L "$BACKUP_DIR/latest" ]; then
            backup_path="$BACKUP_DIR/$(readlink "$BACKUP_DIR/latest")"
            backup_name="latest ($(readlink "$BACKUP_DIR/latest"))"
        else
            print_error "'latest' symlink neexistuje"
            print_info "Pou≈æijte 'uictl list' pro zobrazen√≠ dostupn√Ωch z√°loh"
            return 1
        fi
    elif [[ "$backup_name" == backup_* ]]; then
        backup_path="$BACKUP_DIR/$backup_name"
    else
        backup_path="$BACKUP_DIR/backup_$backup_name"
    fi
    
    if [ ! -d "$backup_path" ]; then
        print_error "Z√°loha neexistuje: $backup_path"
        list_backups
        return 1
    fi
    
    print_info "üîç Porovn√°v√°m aktu√°ln√≠ GNOME nastaven√≠ se z√°lohou: $backup_name"
    
    if [ -f "$backup_path/backup-info.txt" ]; then
        print_info "üìã Informace o z√°loze:"
        cat "$backup_path/backup-info.txt" | sed 's/^/  /'
        echo
    fi
    
    # Perform comparisons
    compare_dconf "$backup_path"
    echo
    compare_config_files "$backup_path"
    echo
    compare_extensions "$backup_path"
    
    echo
    print_info "üîç Porovn√°n√≠ dokonƒçeno"
    print_info "üí° Pro podrobn√© rozd√≠ly pou≈æijte: uictl diff -v $backup_name"
}

# Funkce pro obnoven√≠ nastaven√≠ (ze star√©ho restore.sh)
restore_settings() {
    local restore_path="$1"
    
    if [ ! -d "$restore_path" ]; then
        print_error "Z√°loha neexistuje: $restore_path"
        return 1
    fi
    
    print_info "üîÑ Obnovuji GNOME nastaven√≠ ze z√°lohy: $(basename "$restore_path")"
    
    if [ "$DRY_RUN" = "true" ]; then
        print_warning "üß™ DRY-RUN re≈æim - pouze zobrazuji co by se dƒõlalo"
    fi
    
    if [ -f "$restore_path/backup-info.txt" ] && [ "$VERBOSE" = "true" ]; then
        print_info "üìã Informace o z√°loze:"
        cat "$restore_path/backup-info.txt" | sed 's/^/  /'
        echo
    fi
    
    # Obnoven√≠ dconf nastaven√≠
    if [ -f "$restore_path/dconf/all-settings.ini" ]; then
        print_info "üìä Obnovuji dconf nastaven√≠..."
        if [ "$DRY_RUN" != "true" ]; then
            dconf load / < "$restore_path/dconf/all-settings.ini"
            print_success "Dconf nastaven√≠ obnovena"
        else
            print_verbose "  Obnovil bych: $restore_path/dconf/all-settings.ini"
        fi
    else
        print_warning "Dconf z√°loha nenalezena"
    fi
    
    # Obnoven√≠ konfiguraƒçn√≠ch soubor≈Ø
    if [ -d "$restore_path/config" ]; then
        print_info "üìÅ Obnovuji konfiguraƒçn√≠ soubory..."
        for config_item in "$restore_path/config"/*; do
            if [ -e "$config_item" ]; then
                local item_name=$(basename "$config_item")
                local target_path="$HOME/.config/$item_name"
                
                if [ "$DRY_RUN" != "true" ]; then
                    if [ -e "$target_path" ]; then
                        mv "$target_path" "/tmp/$(basename "$target_path").backup-$(date +%s)" 2>/dev/null || true
                    fi
                    cp -r "$config_item" "$target_path"
                    print_verbose "Obnoveno: $item_name"
                else
                    print_verbose "  Obnovil bych: $item_name -> $target_path"
                fi
            fi
        done
        [ "$DRY_RUN" != "true" ] && print_success "Konfiguraƒçn√≠ soubory obnoveny"
    fi
    
    # Obnoven√≠ extensions
    if [ -d "$restore_path/local/extensions" ]; then
        print_info "üîå Obnovuji GNOME Shell extensions..."
        if [ "$DRY_RUN" != "true" ]; then
            mkdir -p "$HOME/.local/share/gnome-shell"
            if [ -d "$HOME/.local/share/gnome-shell/extensions" ]; then
                mv "$HOME/.local/share/gnome-shell/extensions" "/tmp/extensions.backup-$(date +%s)" 2>/dev/null || true
            fi
            cp -r "$restore_path/local/extensions" "$HOME/.local/share/gnome-shell/extensions"
            print_success "Extensions obnoveny"
        else
            print_verbose "  Obnovil bych u≈æivatelsk√© extensions"
        fi
    fi
    
    # Obnoven√≠ seznamu aktivn√≠ch extensions
    if [ -f "$restore_path/enabled-extensions.txt" ]; then
        print_info "‚úÖ Obnovuji seznam aktivn√≠ch extensions..."
        if [ "$DRY_RUN" != "true" ]; then
            local enabled_extensions=$(cat "$restore_path/enabled-extensions.txt")
            gsettings set org.gnome.shell enabled-extensions "$enabled_extensions"
            print_success "Seznam aktivn√≠ch extensions obnoven"
        else
            print_verbose "  Obnovil bych: $(cat "$restore_path/enabled-extensions.txt")"
        fi
    fi
    
    if [ "$DRY_RUN" != "true" ]; then
        echo
        print_success "üéâ Obnoven√≠ dokonƒçeno!"
        print_warning "‚ö†Ô∏è  Doporuƒçuje se restartovat GNOME Shell (Alt+F2, pak napi≈°te 'r')"
        print_info "üí° Nebo se odhlaste a znovu p≈ôihlaste"
    else
        echo
        print_info "üß™ DRY-RUN dokonƒçen - ≈æ√°dn√© zmƒõny nebyly provedeny"
    fi
}


# Hlavn√≠ logika
main() {
    # Parsov√°n√≠ glob√°ln√≠ch argument≈Ø - p≈ô√≠mo v main kv≈Øli promƒõnn√Ωm
    local remaining_args=()
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--force)
                FORCE=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                if [ -n "$2" ] && [[ ! "$2" =~ ^- ]]; then
                    show_command_help "$2"
                    exit 0
                else
                    show_main_help
                    exit 0
                fi
                ;;
            *)
                # P≈ôidat nerozpoznan√Ω argument do v√Ωsledku
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    if [ ${#remaining_args[@]} -eq 0 ]; then
        show_main_help
        exit 0
    fi
    
    local command="${remaining_args[0]}"
    local cmd_args=("${remaining_args[@]:1}")
    
    case "$command" in
        backup)
            create_backup
            ;;
        restore)
            if [ ${#cmd_args[@]} -eq 0 ]; then
                print_error "Chyb√≠ n√°zev z√°lohy"
                echo "Pou≈æijte: uictl restore <backup>"
                echo "Nebo: uictl list pro zobrazen√≠ dostupn√Ωch z√°loh"
                exit 1
            fi
            
            local backup_name="${cmd_args[0]}"
            local restore_path
            
            if [[ "$backup_name" == "latest" ]]; then
                if [ -L "$BACKUP_DIR/latest" ]; then
                    restore_path="$BACKUP_DIR/$(readlink "$BACKUP_DIR/latest")"
                    backup_name="latest ($(readlink "$BACKUP_DIR/latest"))"
                else
                    print_error "'latest' symlink neexistuje"
                    print_info "Pou≈æijte 'uictl list' pro zobrazen√≠ dostupn√Ωch z√°loh"
                    exit 1
                fi
            elif [[ "$backup_name" == backup_* ]]; then
                restore_path="$BACKUP_DIR/$backup_name"
            else
                restore_path="$BACKUP_DIR/backup_$backup_name"
            fi
            
            if [ ! -d "$restore_path" ]; then
                print_error "Z√°loha neexistuje: $restore_path"
                list_backups
                exit 1
            fi
            
            # Potvrzen√≠ (pokud nen√≠ force mode nebo dry-run)
            if [ "$FORCE" != "true" ] && [ "$DRY_RUN" != "true" ]; then
                echo
                print_warning "üö® POZOR: Tato operace p≈ôep√≠≈°e va≈°e souƒçasn√© GNOME nastaven√≠!"
                print_info "Z√°loha k obnoven√≠: $backup_name"
                print_info "P≈ôed obnoven√≠m bude vytvo≈ôena z√°loha souƒçasn√©ho stavu."
                echo
                read -p "Pokraƒçovat? (ano/ne): " -r
                if [[ ! $REPLY =~ ^[Aa]no$ ]]; then
                    print_info "Operace zru≈°ena"
                    exit 0
                fi
            fi
            
            # Vytvo≈ôen√≠ z√°lohy p≈ôed obnoven√≠m (pokud nen√≠ dry-run)
            if [ "$DRY_RUN" != "true" ]; then
                create_pre_restore_backup
            fi
            
            restore_settings "$restore_path"
            ;;
        list)
            list_backups
            ;;
        status)
            show_status
            ;;
        diff)
            # Default to latest if no backup specified
            local backup_name="latest"
            if [ ${#cmd_args[@]} -gt 0 ]; then
                backup_name="${cmd_args[0]}"
            fi
            
            diff_settings "$backup_name"
            ;;
        clean)
            # Parsov√°n√≠ argument≈Ø pro clean - prvn√≠ non-option argument je poƒçet
            local keep_count=10
            local i=0
            while [ $i -lt ${#cmd_args[@]} ]; do
                arg="${cmd_args[$i]}"
                if [[ "$arg" =~ ^[0-9]+$ ]]; then
                    keep_count="$arg"
                    break
                fi
                ((i++))
            done
            clean_old_backups "$keep_count"
            ;;
        help)
            if [ ${#cmd_args[@]} -gt 0 ]; then
                show_command_help "${cmd_args[0]}"
            else
                show_main_help
            fi
            ;;
        *)
            print_error "Nezn√°m√Ω p≈ô√≠kaz: $command"
            echo
            show_main_help
            exit 1
            ;;
    esac
}

# Spu≈°tƒõn√≠ hlavn√≠ funkce
main "$@"